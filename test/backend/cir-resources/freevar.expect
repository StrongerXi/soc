closure <equal_35> = {
  args = (native_arg_37, native_arg_36)
  free_vars = ()
  body = {
    (<native:equal> native_arg_37 native_arg_36)
  }
}
closure <addInt_32> = {
  args = (prim_arg_34, prim_arg_33)
  free_vars = ()
  body = {
    (+ prim_arg_34 prim_arg_33)
  }
}
closure <subInt_29> = {
  args = (prim_arg_31, prim_arg_30)
  free_vars = ()
  body = {
    (- prim_arg_31 prim_arg_30)
  }
}
closure <mulInt_26> = {
  args = (prim_arg_28, prim_arg_27)
  free_vars = ()
  body = {
    (* prim_arg_28 prim_arg_27)
  }
}
closure <ltInt_23> = {
  args = (prim_arg_25, prim_arg_24)
  free_vars = ()
  body = {
    (< prim_arg_25 prim_arg_24)
  }
}
closure <logicOr_20> = {
  args = (prim_arg_22, prim_arg_21)
  free_vars = ()
  body = {
    (|| prim_arg_22 prim_arg_21)
  }
}
closure <logicAnd_17> = {
  args = (prim_arg_19, prim_arg_18)
  free_vars = ()
  body = {
    (&& prim_arg_19 prim_arg_18)
  }
}
closure <closure_16> = {
  args = (x_2)
  free_vars = (g_0)
  body = {
    (g_0 x_2)
  }
}
closure <closure_15> = {
  args = (x_3)
  free_vars = (f_1)
  body = {
    (f_1 x_3)
  }
}
closure <closure_12> = {
  args = (x_5, y_6, z_7)
  free_vars = (+)
  body = {
    (MK_CLOSURE <closure_13> y_6 +)
  }
}
closure <closure_13> = {
  args = (x_8)
  free_vars = (y_6, +)
  body = {
    (MK_CLOSURE <closure_14> y_6 x_8 +)
  }
}
closure <closure_14> = {
  args = (a_9, b_10, c_11)
  free_vars = (y_6, x_8, +)
  body = {
    (+ (+ x_8 a_9) y_6)
  }
}
let + = (MK_CLOSURE <addInt_32> )
    - = (MK_CLOSURE <subInt_29> )
    * = (MK_CLOSURE <mulInt_26> )
    < = (MK_CLOSURE <ltInt_23> )
    || = (MK_CLOSURE <logicOr_20> )
    && = (MK_CLOSURE <logicAnd_17> )
    = = (MK_CLOSURE <equal_35> )
in let rec f_1 = (MK_CLOSURE <closure_16> g_0)
           g_0 = (MK_CLOSURE <closure_15> f_1)
   in let f1_4 = (MK_CLOSURE <closure_12> +)
      in 42